#!/usr/bin/env python3"""PET RegistrationBased on original script by Siddhartha Dhiman (@TheJaeger), automated, modified    and parallelized by Ryn Thorn    "Usage: python 1_PET_Registration.py <petDir> <fsDir> <outPath> [subjectID]""""import osimport os.path as opimport globfrom shutil import copyfileimport subprocessfrom itertools import compressimport sysfrom concurrent.futures import ProcessPoolExecutor, as_completed# ============================================# Helper function: process one subject# ============================================def process_subject(path_pet, path_fs, outPath):    subj_name = op.basename(path_pet)    try:        ctacPath = glob.glob(op.join(path_pet, '*AC_CT_Brain_(CTAC).nii.gz'))[-1]        suvPath = glob.glob(op.join(path_pet, '*PET_Brain_AC.nii.gz*'))[-1]        t1Path = op.join(path_fs, 'mri', 'T1.mgz')        outDir = op.join(outPath, subj_name)        os.makedirs(outDir, exist_ok=True)        path_t1 = op.join(outDir, 'T1.nii.gz')        path_omat = op.join(outDir, 'CTAC_2_T1.mat')        path_ctac = op.join(outDir, 'CTAC.nii.gz')        path_suv = op.join(outDir, 'SUV.nii.gz')        path_ctac_std = op.join(outDir, 'CTAC_STD.nii.gz')        path_suv_std = op.join(outDir, 'SUV_STD.nii.gz')        path_suv_ctac = op.join(outDir, 'SUV_2_CTAC.nii.gz')        path_ctac_reg = op.join(outDir, 'CTAC_REG.nii.gz')        path_suv_reg = op.join(outDir, 'SUV_REG.nii.gz')        path_suv_reg_thr = op.join(outDir, 'SUV_REG_THR.nii.gz')        path_suv_reg_reslice = op.join(outDir, 'SUV_REG_reslice.nii.gz')        if op.exists(path_suv_reg):            return subj_name, None  # already processed        print(f"Processing {subj_name}")        def run_cmd(arg):            """Run shell command safely with output capture"""            result = subprocess.run(arg, capture_output=True, text=True)            if result.returncode != 0:                raise RuntimeError(f"Command failed: {' '.join(arg)}\n{result.stderr}")            return result        # Convert T1 to NIfTI        run_cmd(['mrconvert', '-force', t1Path, path_t1])        # Copy PET        copyfile(ctacPath, path_ctac)        copyfile(suvPath, path_suv)        # Reorient CTAC & SUV        run_cmd(['fslreorient2std', path_ctac, path_ctac_std])        run_cmd(['fslreorient2std', path_suv, path_suv_std])        # Register SUV to CTAC        run_cmd(['flirt', '-ref', path_ctac_std, '-in', path_suv_std, '-out', path_suv_ctac, '-v'])        # Register CTAC to T1        run_cmd([            'flirt', '-ref', path_t1, '-in', path_ctac_std, '-out', path_ctac_reg,            '-omat', path_omat, '-dof', '6', '-cost', 'mutualinfo', '-searchcost', 'mutualinfo', '-v'        ])        # Apply affine to SUV        run_cmd([            'flirt', '-ref', path_t1, '-in', path_suv_ctac, '-out', path_suv_reg,            '-init', path_omat, '-dof', '6', '-applyxfm', '-v'        ])        # Threshold SUV        run_cmd(['fslmaths', path_suv_reg, '-thr', '0', path_suv_reg_thr])        # Reslice SUV_REG        run_cmd(['flirt', '-ref', path_t1, '-in', path_suv_reg_thr, '-out', path_suv_reg_reslice])        # Clean up (optional)        # os.remove(path_suv_reg)        # os.remove(path_suv_reg_thr)        # os.rename(path_suv_reg_reslice, path_suv_reg)        return subj_name, None    except Exception as e:        return subj_name, str(e)# ============================================# Main script# ============================================if __name__ == "__main__":    if len(sys.argv) < 4:        print("Usage: python 1_PET_Registration.py <petDir> <fsDir> <outPath> [subjectID]")        sys.exit(1)    petDir = sys.argv[1]    fsDir = sys.argv[2]    outPath = sys.argv[3]    subj = sys.argv[4] if len(sys.argv) > 4 else None    print(f"\nPET directory: {petDir}")    print(f"FS directory: {fsDir}")    print(f"Output directory: {outPath}")    if subj:        print(f"Running only subject: {subj}")    print("==========================================\n")    # --- Subject filtering ---    paths_pet = sorted(glob.glob(op.join(petDir, 'IAM_*')))    paths_fs = sorted(glob.glob(op.join(fsDir, 'IAM_*')))    subs_pet = [op.basename(x) for x in paths_pet]    subs_fs = [op.basename(x) for x in paths_fs]    idx = [x in subs_fs for x in subs_pet]    subs_pet = list(compress(subs_pet, idx))    idx = [x in subs_pet for x in subs_fs]    subs_fs = list(compress(subs_fs, idx))    paths_pet = sorted([op.join(petDir, x) for x in subs_pet])    paths_fs = sorted([op.join(fsDir, x) for x in subs_fs])    # Optional single subject    if subj:        paths_pet = [p for p in paths_pet if subj in p]        paths_fs = [p for p in paths_fs if subj in p]    # --- Run in parallel ---    failed = []    max_workers = os.cpu_count() or 4  # auto-detect available cores    print(f"Running up to {max_workers} subjects in parallel...\n")    with ProcessPoolExecutor(max_workers=max_workers) as executor:        futures = {executor.submit(process_subject, p_pet, p_fs, outPath): op.basename(p_pet)                   for p_pet, p_fs in zip(paths_pet, paths_fs)}        for future in as_completed(futures):            subj_name = futures[future]            try:                subj, err = future.result()                if err:                    print(f"‚ùå {subj_name} failed: {err}")                    failed.append(subj_name)                else:                    print(f"‚úÖ {subj_name} completed successfully")            except Exception as e:                print(f"üí• Exception in {subj_name}: {e}")                failed.append(subj_name)    # --- Summary ---    if failed:        print("\nFailed subjects:", failed)    else:        print("\nAll subjects completed successfully!")