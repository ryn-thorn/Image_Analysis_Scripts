#!/usr/bin/env python3"""PET RegistrationBased on original script by Siddhartha Dhiman (@TheJaeger), automated, modified    and parallelized by Ryn Thorn"""import osimport os.path as opimport globfrom shutil import copyfileimport subprocessimport sysfrom concurrent.futures import ProcessPoolExecutor, as_completed# ============================================# Helper function: process one subject# ============================================def process_subject(path_pet, path_fs, outPath):    subj_name = op.basename(path_pet)    try:        ctac_files = glob.glob(op.join(path_pet, '*AC_CT_Brain_(CTAC).nii.gz'))        suv_files = glob.glob(op.join(path_pet, '*PET_Brain_AC.nii.gz*'))        # --- Skip subjects missing required inputs ---        if not ctac_files:            return subj_name, "Missing CTAC file"        if not suv_files:            return subj_name, "Missing PET_Brain_AC file"        ctacPath = ctac_files[-1]        suvPath = suv_files[-1]        t1Path = op.join(path_fs, 'mri', 'T1.mgz')        outDir = op.join(outPath, subj_name)        os.makedirs(outDir, exist_ok=True)        path_t1 = op.join(outDir, 'T1.nii.gz')        path_omat = op.join(outDir, 'CTAC_2_T1.mat')        path_ctac = op.join(outDir, 'CTAC.nii.gz')        path_suv = op.join(outDir, 'SUV.nii.gz')        path_ctac_std = op.join(outDir, 'CTAC_STD.nii.gz')        path_suv_std = op.join(outDir, 'SUV_STD.nii.gz')        path_suv_ctac = op.join(outDir, 'SUV_2_CTAC.nii.gz')        path_ctac_reg = op.join(outDir, 'CTAC_REG.nii.gz')        path_suv_reg = op.join(outDir, 'SUV_REG.nii.gz')        path_suv_reg_thr = op.join(outDir, 'SUV_REG_THR.nii.gz')        path_suv_reg_reslice = op.join(outDir, 'SUV_REG_reslice.nii.gz')        if op.exists(path_suv_reg):            return subj_name, None  # already processed        print(f"Processing {subj_name}")        def run_cmd(arg):            result = subprocess.run(arg, capture_output=True, text=True)            if result.returncode != 0:                raise RuntimeError(f"Command failed: {' '.join(arg)}\n{result.stderr}")            return result        run_cmd(['mrconvert', '-force', t1Path, path_t1])        copyfile(ctacPath, path_ctac)        copyfile(suvPath, path_suv)        run_cmd(['fslreorient2std', path_ctac, path_ctac_std])        run_cmd(['fslreorient2std', path_suv, path_suv_std])        run_cmd(['flirt', '-ref', path_ctac_std, '-in', path_suv_std, '-out', path_suv_ctac, '-v'])        run_cmd([            'flirt', '-ref', path_t1, '-in', path_ctac_std, '-out', path_ctac_reg,            '-omat', path_omat, '-dof', '6', '-cost', 'mutualinfo', '-searchcost', 'mutualinfo', '-v'        ])        run_cmd([            'flirt', '-ref', path_t1, '-in', path_suv_ctac, '-out', path_suv_reg,            '-init', path_omat, '-dof', '6', '-applyxfm', '-v'        ])        run_cmd(['fslmaths', path_suv_reg, '-thr', '0', path_suv_reg_thr])        run_cmd(['flirt', '-ref', path_t1, '-in', path_suv_reg_thr, '-out', path_suv_reg_reslice])        return subj_name, None    except Exception as e:        return subj_name, str(e)# ============================================# Main script# ============================================if __name__ == "__main__":    if len(sys.argv) < 4:        print("Usage: python 1_PET_Registration.py <petDir> <fsDir> <outPath>")        sys.exit(1)    petDir = sys.argv[1]    fsDir = sys.argv[2]    outPath = sys.argv[3]    print(f"\nPET directory: {petDir}")    print(f"FS directory: {fsDir}")    print(f"Output directory: {outPath}")    print("==========================================\n")    paths_pet = sorted(glob.glob(op.join(petDir, 'IAM_*')))    subs_pet = [op.basename(x) for x in paths_pet]    paths_fs = [op.join(fsDir, s) for s in subs_pet if op.exists(op.join(fsDir, s))]    paths_pet = [op.join(petDir, s) for s in subs_pet if op.exists(op.join(fsDir, s))]    # --- Limit parallel jobs to 4 ---    failed = []    max_workers = 4    print(f"Running up to {max_workers} subjects in parallel...\n")    with ProcessPoolExecutor(max_workers=max_workers) as executor:        futures = {executor.submit(process_subject, p_pet, p_fs, outPath): op.basename(p_pet)                   for p_pet, p_fs in zip(paths_pet, paths_fs)}        for future in as_completed(futures):            subj_name = futures[future]            try:                subj, err = future.result()                if err:                    print(f"‚ùå {subj_name} failed: {err}")                    failed.append(subj_name)                else:                    print(f"‚úÖ {subj_name} completed successfully")            except Exception as e:                print(f"üí• Exception in {subj_name}: {e}")                failed.append(subj_name)    if failed:        print("\nFailed subjects:", failed)    else:        print("\nAll subjects completed successfully!")